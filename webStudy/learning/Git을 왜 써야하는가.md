## Git을 왜 써야하는가?

### 목차

1. Git을 왜 써야하는가?
2. Git 명령어 간략 소개
3. Git Branch 전략, 다른 회사들의 Git 사용 방법
4. Git 동작 방식
5. 출처

- Git을 왜 써야하는가?

  - 내가 생성한 파일의 버전관리
    소프트웨어에는 버전관리가 필요하다. 꼭 클라이언트의 요청이 없더라도, 버전별로 이전 버전의 기능을 다시 가져오게 될 수도 있고, 누군가 잘못된 코드를 섞으면 복원해야 될 때도 있기 때문이다.
    그래서 언제든 특정 시점의 버전을 다시 이용하는데 문제가 없게끔 변경된 내역을 관리해줘야 하는 것이다.
    이 때 필요한 것이 버전관리를 위한 툴, Git이다.

  - 효과적인 협업
    Git은 각자의 작업 내용을 클라우드 환경에 저장.
    Git은 일반적인 다른 버전 관리 시스템보다 성능이 뛰어나며, 변경 이력이 많더라도 변경된 내용만 처리한다는 점에서 메모리적인 효율성 또한 뛰어나다.
    어느 정도 규모가 있는 프로젝트를 진행할 때는 혼자가 아닌 여러명의 개발자가 협업하게 된다.
    하나의 공유 가능한 공간 안에서 여러 개발자들이 각각 맡은 파트를 가져가서 작업하고, 작업사항을 업데이트하고, 서로의 작업 로그를 살펴볼 수 있어야 하며, 이에 더해 버전별 백업도 실시간으로 진행해야 한다.
    하지만 여러 사람이 모듈별로 나누어 실시간으로 작업하는 소프트웨어 개발의 특성상 로컬 저장소라던지 메일이나 클라우드를 통해 관리하려면 어렵고 불편하다.
    따라서 작업 중 실시간으로 작업내역을 공유할 수 있는 원격저장소가 필요하다. 이 때 필요한 것이 협업을 위한 저장소, Github이다.
  - 효율적인 배포 관리
    서비스의 복잡도에따라 배포까지는 몇 번의 과정들을 겪어야한다.
    이때 git을 사용하면 언제든 새로운 내용들을 기록하여 배포할 수 있고 또 장애 등의 문제가 발생하더라도 원하는 배포시점으로 돌아갈 수 있게된다.

- Git 명령어 간략 소개

  - git init : git 생성하기
  - git clone git_path : 코드가져오기
  - git branch branch_name : 브랜치 생성하기
  - git checkout branch_name : 브랜치 선택하기
  - git branch -d branch_name : 브랜치 삭제하기
  - git pull : git서버에서 최신 코드 받아와 merge 하기
  - git fetch : git서버에서 최신 코드 받아오기
  - git commit -m 메시지: 새로운 버전을 생성하기
  - git reset — hard HEAD^ : commit한 이전 코드 취소하기
  - git reset — soft HEAD^ : 코드는 살리고 commit만 취소하기
  - git reset — merge : merge 취소하기

- Git Branch 전략, 다른 회사들의 Git 사용 방법

  브랜치 전략이란 여러 개발자가 하나의 저장소를 사용하는 환경에서 저장소를 효과적으로 활용하기 위한 work-flow이다.
  브랜치의 생성, 삭제, 병합 등 git의 유연한 구조를 활용해서 각 개발자들의 혼란을 최대한 줄이며 다양한 방식으로 소스를 관리하는 역할을 한다. 즉, 브랜치 생성에 규칙을 만들어서 협업을 유연하게 하는 방법론이다.
  Github-flow는 1개의 master 브랜치와 PR을 활용한 단순하고 민첩한 브랜치 전략이다.
  master 브랜치는 제품이 릴리즈되는 가장 최신 버전의 브랜치이며, 모든 개발 내용이 master 브랜치를 중심으로 이루어진다.
  **간단하고 민첩한 Github-flow**

  ![image-20211102112749087](https://user-images.githubusercontent.com/88412911/139777045-ccc5cb72-fe2a-40c4-a63d-c20512564f63.png)

  1. 브랜치 생성

  ![image-20211102113230208](https://user-images.githubusercontent.com/88412911/139777341-6139e7fc-cee9-4a51-a9b5-ccbe6dc73d31.png)

  Github-flow 전략은 기능 개발, 버그 픽스 등 어떤 이유로든 새로운 브랜치를 생성하는 것으로 시작된다. 단, 이때 체계적인 분류 없이 브랜치 하나에 의존하게 되기 때문에 **브랜치 이름을 통해 의도를 명확하게 드러내는 것이 매우 중요**하다.

  2. Commit

  ![image-20211102113615762](https://user-images.githubusercontent.com/88412911/139777646-70a2e306-6931-4234-9520-793071341510.png)

  열심히 개발을 진행하면서 열심히 커밋을 남긴다!
  이때도 브랜치와 같이 커밋 메세지에 의존해야 하기 때문에, 커밋 메세지를 최대한 상세하게 적어주는 것이 중요하다.

  3. PR 생성

  ![image-20211102113751016](https://user-images.githubusercontent.com/88412911/139777754-7a4efb67-2494-46c1-9f51-8c916418d93a.png)

  개발이 완료되었다면 master 브랜치 쪽으로 Pull-Request를 생성한다.

  4. Review

  ![image-20211102113938949](https://user-images.githubusercontent.com/88412911/139777919-f765e4db-61f6-4a62-a5f1-a1534282a319.png)

  충분한 리뷰와 토의를 거친다. Pull-Request가 master 브랜치 쪽에 합쳐진다면 곧장 라이브 서버에 배포되는 것과 다름 없으므로 굉장히 상세한 리뷰와 토의가 이루어져야만 한다.

  5. Review 후 테스트

  ![image-20211102114129033](https://user-images.githubusercontent.com/88412911/139778095-df2f6399-e2eb-466e-a918-9c757d157b5f.png)

  

  리뷰가 끝났다면 해당 내용을 라이브 서버(혹은 테스트 환경)에 배포해본다.
  배포시 문제가 발생한다면 곧장 master 브랜치의 내용을 다시 배포하여 초기화 시킨다.

  6. 최종 병합(Merge)

  ![image-20211102114300839](https://user-images.githubusercontent.com/88412911/139778242-42f32226-ff6e-411d-9738-36598ef733e1.png)

  라이브 서버(혹은 테스트 환경)에 배포했음에도 문제가 발견되지 않았다면 그대로 master 브랜치에 푸시를 하고, 즉시 배포를 진행한다.
  대부분의 Github-flow 에선 master 브랜치를 최신 브랜치라고 가정하기 때문에 배포 자동화 도구를 이용해서 Merge 즉시 배포를 시킨다.

  **복잡하지만 체계적인 git-flow**

  ![image-20211102115054736](https://user-images.githubusercontent.com/88412911/139778921-c4828502-d77a-421c-9eec-f063277e9148.png)

  **git-flow**는 5가지의 브랜치를 이용해서 저장소를 운영하는 브랜치 전략이다.
  5가지 중 항시 유지되는 메인 브랜치 master, develop 2가지와
  merge 되면 사라지는 보조 브랜치 feature, release, hotfix 3가지로 구성된다.

  - `master` : 라이브 서버에 제품으로 출시되는 브랜치
  - `develop` : 다음 출시 버전을 대비하여 개발하는 브랜치
  - `feature` : 기능 개발 브랜치. `develop` 브랜치에 들어간다
  - `release` : 다음 버전 출시를 준비하는 브랜치. `develop` 브랜치를 `release` 브랜치로 옮긴 후 QA, 테스트를 진행하고 `master` 브랜치로 합친다
  - `hotfix` : `master` 브랜치에서 발생한 버그를 수정하는 브랜치

  <u>1개월 이상의 긴 호흡으로 개발하여 주기적으로 배포, QA 및 테스트, hotfix 등 수행할 수 있는 여력이 있는 팀이라면 **git-flow**가 적합하다.</u>

  <u>수시로 릴리즈 되어야 할 필요가 있는 서비스를 지속적으로 테스트하고 배포하는 팀이라면 **github-flow** 와 같은 간단한 work-flow가 적합하다.</u>

- Git 동작 방식
  Git 의 동작 방식을 바르게 이해하기 위해서는 Git 프로젝트의 세 가지 구성요소에 대해서 이해 해야한다.
  - Working Directory : 작업할 파일이 있는 디렉토리
  - Staging Area : 커밋(Commit)을 수행할 파일들이 올라가는 영역
  - Git Directory : Git 프로젝트의 메타 데이터와 데이터 정보가 저장되는 디렉토리

![image-20211102135319819](https://user-images.githubusercontent.com/88412911/139788809-866a13a2-0659-4016-a793-833fe9ca2d6d.png)

그림은 실제 소스코드를 수정하는 작업을 해서 커밋(commit) 하고, 다시 저장소에 있는 수정 내역을 자신의 컴퓨터로 옮기는 과정들을 도표로 나타낸 것이다.
이 도표는 위의 내용에서 다룬 원격지에 있는 저장소(remote repository) 에서 맨 처음에 클론을 받아 자신의 컴퓨터에 해당 프로젝트가 통째로 다운로드 된 후 수정내역을 다루는 방법을 나타낸 것이다.
클론받은 프로젝트를 수정한 후 수정 내역을 다시 원격지 정소까지 반영하려면, git add, git commit, git push 의 과정을 거쳐야 한다.
이후에 다시 저장소로부터 수정된 내역을 받을 때에는 git fetch 를 수행한다.
다만, 이러한 과정에서 내가 수정한 내역이 원격지 저장소에 있는 내역과 다를 수 있기 때문에 git merge를 수행하여 자신의 컴퓨터에 있는 소스코드와 원격지 저장소에 있는 소스코드를 똑같이 만들어야한다.



- 출처
  - https://y-oni.tistory.com/84
  - https://pks2974.medium.com/%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B8%B0%EC%B4%88-git-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-533b3689db81
  - https://hyeon9mak.github.io/git-branch-strategy/
  - https://chohyeonjunn.tistory.com/73